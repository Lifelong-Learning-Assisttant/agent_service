# 1. Краткая ролевая карта

* **Пользователь** — присылает запрос (напр. «сгенерируй 5 квизов по теме X для уровня Y»).
* **Agent (FastAPI)** — HTTP-сервис, реализует LLM-агента (на базе LangChain или Langraph). Отвечает за анализ запроса, план действий, оркестрацию tool-ов и формирование финального ответа/квизов.
* **tavily_search_tool (HTTP)** — веб-поиск; даёт свежие ссылки/сниппеты/фрагменты. Может поддерживать sync/SSE.
* **rag (HTTP retriever + vector DB)** — поиск по векторному индексу (Qdrant и т.п.) — возвращает релевантные документы/фрагменты и метаданные.
* **test_generator (HTTP)** — принимает контекст/источники и генерирует тесты/вопросы/разборы/оценку.
* Все сервисы — запущены в контейнерах на одном сервере, с заранее назначенными статическими портами.

# 2. Высокоуровневый поток (шаги)

1. **Приём запроса:** пользователь → `POST /agent/api/request` (FastAPI агента). В теле: user_id, intent_text, параметры (уровень, формат, кол-во квизов и т.д.), опционально `trace_id`.
2. **NLU / parse intent:** агент парсит запрос (intent + slots), определяет необходимые подзадачи: нужен ли веб-поиск, нужен ли RAG, формат выдачи.
3. **План действий (planner):** агент строит план, например:

   * step A: tavily search → свежие источники;
   * step B: rag retrieve → локальные/предзагруженные документы;
   * step C: агрегировать источники, очистить/фильтровать;
   * step D: вызвать test_generator с контекстом → получить квизы;
   * step E: вернуть/stream ответ пользователю.
4. **Вызов tavily (опционально):** агент POST/GET → `tavily:/search` с query; получает список результатов (title, snippet, url, published_date). Если tavily поддержует стрим прогресса — агент может подписаться на SSE для получения ранних результатов.
5. **Вызов rag:** агент отправляет сформулированный запрос/embedding (или текст) → `rag:/retrieve` → получает набор релевантных пассages с source_id, score, highlights.
6. **Агрегация и ранжирование:** агент объединяет данные от tavily + rag, дедуплицирует, отфильтровывает нерелевантное, может выполнить дополнительный шаг — извлечь сущности/факты.
7. **Подготовка prompt/context для генерации:** агент формирует prompt-шаблон(ы) для test_generator: включает сводку источников, ограничения по формату (JSON schema или структуры), требования к сложности/ответам/вариантам.
8. **Вызов test_generator:** `POST /test_generator/api/generate` с payload: `{context, constraints, format: "json_schema_v1", num_quizzes: N}`. Test_generator возвращает готовые квизы (sync) или job_id + SSE/ status (async) если генерация долгая.
9. **Валидация & финализация:** агент валидирует ответ по ожидаемой схеме, при необходимости делает post-edit (LLM-коррекция) или просит test_generator пересгенерировать части.
10. **Ответ пользователю:** агент возвращает финальные квизы: либо в одном ответе, либо потоково (SSE/WebSocket) если пользователь хочет прогресс. Логи и trace записаны.

# 3. Контракты / ожидания от сервисов (минимум)

* Каждый сервис должен иметь: `health` endpoint (`GET /health`), `openapi.json` или docs, и основной invoke endpoint (`/search`, `/retrieve`, `/generate`).
* Для длинных задач — поддержка `POST /start` -> `job_id`, `GET /status/{job_id}`, `POST /cancel/{job_id}`.
* Для потоков — поддержка SSE `GET /events?job_id=...` или WebSocket (если нужна двунаправленность).
* Все ответы должны включать метаданные: `source`, `timestamp`, `confidence/score`, `trace_id` (если был передан).

# 4. Потоковые решения: SSE vs WebSocket vs sync

* **Sync HTTP (POST/response)** — предпочтительно для большинства вызовов (tavily для коротких запросов, rag retrieve, test_generator если быстрый). Простая, надёжная.
* **SSE (Server→Agent)** — полезно, если сервис хочет пушить прогресс/частичные результаты к агенту (например длительная генерация в test_generator или потоковые результаты поиска). SSE — только однонаправлен: сервер → агент. Для cancel/control потребуется отдельный control endpoint.
* **WebSocket** — выбирать если нужен живой двунаправленный диалог (напр., агент посылает промежуточные уточнения в процесс генерации, или интерактивный режим). Сложнее в инфрастуктуре, но даёт гибкость.
* **Рекомендация:** оставляем **sync HTTP** по умолчанию; добавляем **SSE** для длительной генерации прогресса (test_generator) и оставляем `POST /cancel` для управления задачей. WebSocket — если в будущем планируешь интерактивный поток между агентом и сервисом.

# 5. Поведенческие паттерны агента (practical)

* **Retry & backoff:** для внешних вызовов (tavily) с лимитом ретраев.
* **Timeouts:** per-call таймауты (короткие для tavily, длиннее для генерации).
* **Graceful fallback:** если tavily не доступен — полагаться на rag (локальная база) + пометка «источники неактуальны».
* **Кэширование:** кешировать результаты поиска tavily + retrieved passages по ключевому запросу (TTL).
* **Fact-checking:** помечать сгенерированные вопросы с ссылками на источники; включать provenance (откуда взят факт).
* **Rate/Cost control:** иметь лимит на кол-во вызовов LLM/внешних API в одном запросе (стоимость).

# 6. Observability, tracing & security

* **Trace id**: генерировать `trace_id` в начале запроса, пробрасывать во все вызовы (tavily, rag, test_generator).
* **Логирование**: запросы/ответы (не выводя PII), ошибки, latency per-step.
* **Metrics**: RPS, error rates, avg latency per tool, queue length.
* **Auth**: internal API keys / mTLS between services; для внешнего tavily — API key. На одном сервере можно ограничить доступ по firewall / unix socket.
* **Rate limiting** и **circuit breaker** для внешних сервисов.

# 7. Примеры сценариев (коротко)

* **Быстрое**: пользователь: «сгенерируй 3 вопроса по теме X». Агент → RAG (локальные факты) → формирует prompt → тест-генератор sync → ответ.
* **Свежая инфа**: «Что нового по теме X — сделай квиз» → агент сначала tavily → получает новости → rag для расширения → агрегирует → test_generator → выдача.
* **Большой пакет**: «100 квизов» → агент запускает job в test_generator (async), подписывается на SSE, периодически отсылает прогресс пользователю.

# 8. Почему LangChain vs Langraph (коротко)

* **LangChain** — зрелая экосистема для цепочек, агентов, много адаптеров/интеграций (HTTP tools, retrievers, caching). Быстро настраивается для orchestrator’а.
* **Langraph** — ориентирован на графовые представления рассуждений и может быть удобен, если хочешь явный граф зависимостей и пошаговый трассинг.
* **Рекомендация:** если цель — быстрый продакт-прототип — **LangChain**; если важна формальная визуализация процесса рассуждений/graph-oriented debugging — **Langraph**.

# 9. Небольшой checklist для запуска

* Создать `tools.json` у агента с base_url/ports для tavily/rag/test_generator + health endpoints.
* Реализовать в сервисах: `/health`, `openapi.json`, `POST /invoke` (или `/generate`), `POST /start`+`GET /status`+`POST /cancel` для долгих задач.
* Добавить tracing headers и логирование в каждом сервисе.
* Решить стратегию стриминга для конечного пользователя (sync vs SSE vs WebSocket).
* Настроить таймауты, retry/backoff, кеширование для tavily.
